# 🚧فصل چهارم. ‫کدگذاری و Evolution
راجع به
forward- and backward-compatibility
در داده‌ها صحبت کرده.

تغییر در برنامه منجر به تغییر در داده هم می‌شود.

کد جدید با داده‌ی قدیمی 
(backward-compatibility)
و کد قدیمی با داده‌های جدید
(forward-compatibility)
بتوانند کار کنند

حتی در برنامه‌های سمت سرور هم تغییرات مرحله‌ای اعمال می‌شوند که منجر به کار با داده‌های قدیمی‌تر یا جدیدتر می‌شود.

کلمه‌ی
Evolution
در این فصل به معنی تغییر ساختار داده در طول زمان به کار رفته.

> ‫**ℹ️** در این فصل چند فرمت ذخیره‌سازی ذکر کرده و برای هر کدام روش برخورد با موارد بالا، اسکیما و روش استفاده در انتقال اطلاعات را بررسی کرده.

## Formats for Encoding Data
دو نوع نمایش لازم است:
- در حافظه
- در فایل

به نوعی ترجمه بین دو حالت بالا نیاز است.
- coding & encoding

### Language-Specific Formats
روش‌های مختص زبان‌های برنامه‌نویسی مثل
pickle
در
Python،
یا
Serializable
در
Java
و
Marshal
در
Ruby.

مشکلات:
- در زبان‌های دیگر سخت خوانده می‌شوند
- مشکلات امنیتی به خاطر احتمال وجود کد اجرایی یا دسترسی به حافظه
- ورژنینگ
- کارایی

در کل ایده‌ی بدی است.

### JSON, XML and Binary Variants
فرمت‌های ذخیره‌سازی
JSON, XML و CSV
هم مشکلات خودشان را دارند:
- ابهام در ذخیره‌ی اعداد
- عدم پشتیبانی باینری - نیاز به راهکارهایی مثل
base64
هست که حجم داده‌ها را تا ۳۳ درصد بیشتر می‌کند
- پشتیبانی اسکیما اختیاری، قوی اما پیچیده برای یادگیری و پیاده‌سازی است
- CSV
اسکیما ندارد و فرمت سطر و ستون هم در آن اختیاری است و بسیاری از پارسرها هم قوانین
scaping
را به درستی برای آن پیاده نکرده‌اند.

با وجود این مشکلات به اندازه‌ی کافی خوب هستند که تا مدت زیادی قابل استفاده باقی بمانند.

فرمت‌های زیادی برای ذخیره‌ی باینری
XML و JSON
پیاده‌سازی شده‌اند.

- JSON: MessagePack, BSON, BJSON, UBJSON, BISON, Smile
- XML: WBXML, Fast Infoset

### Thrift and Protocol Buffers
هر دو فرمت‌های باینری ذخیره‌ی داده هستند و بنا بر اصل مشترکی بنا شده‌اند.

هر دو به فیلدها شماره می‌دهند که بعدا با تغییر نام آن‌ها را گم نکنند و همچنین برای ذخیره‌ی اعداد از یک سیستم کدینگ باینری استفاده می‌کنند که بتوانند اندازه‌های مختلف را در یک ساختار مشترک پشتیبانی کنند.

برای مثال در
Thrift
ست کردن بالاترین بیت یک بایت یعنی بایت بعدی نیز وجود دارد.

برای هر دو فرمت ابزارهای تولید خودکار کد وجود دارد که کدینگ و دیکدینگ را در زبان‌های برنامه‌نویسی مختلف ساده می‌کند.

تغییر اسکیما نیاز به تنظیم دستی شماره فیلدها دارد.

### Avro
راجع به پشتیبانی از اسکیماهای مختلف برای خواندن و نوشتن صحبت کرده و تغییر آن‌ها در
Evolution
و همچنین
backward- and forward-compatibility.

در
Avro
فیلدها شماره ندارند که پشتیبانی از
dynamically generated schema
را امکان‌پذیر می‌کند.


### The Merits of Schemas

## Models of Dataflow
### Dataflow Through Databases
### Dataflow Through Services: Rest and RPC
### Message-Passing Dataflow

[back](README.md)