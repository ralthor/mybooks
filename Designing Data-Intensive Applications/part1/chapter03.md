# 🚧فصل سوم. ذخیره و بازیابی
هدف نوشتن در پایگاه داده و سپس بازیابی اطلاعات است.

## Data structures for Databases
یک مثال ساده از یک بانک اطلاعاتی زده:
- ذخیره: اضافه به انتهای یک فایل - داده جدید جایگزین نمی‌شود بلکه فقط اضافه می‌شود.
- ‫بازیابی: استفاده از دستور grep برای کلید

کارایی نوشتن بسیار بالاست. در پایگاه‌های داده چیزی به نام
log
برای نوشتن استفاده می‌شود که به همین صورت کار می‌کند.

اما کارایی خواندن وقتی داده زیاد باشد بسیار پایین است.
برای بهبود زمان خواندن، از ایندکسینگ استفاده می‌کنیم.

ایندکس داده‌ای اضافه و به دست آمده از داده‌ی اصلی است.

ایندکس‌ها زمان نوشتن را بیشتر می‌کنند، و به صورت پیش‌فرض اعمال نمی‌شوند. توسعه‌دهنده‌ی سیستم باید فیلد(هایی) که ایندکس لازم دارند معرفی کند.

### Hash indexes
از ساختار
hash-map
که در زبان‌های برنامه‌نویسی پشتیبانی می‌شود استفاده می‌کند.
یک
hash-map
در حافظه‌ی اصلی برنامه کلید‌ها را نگه می‌دارد و هر کلید مکان رکورد در فایل را نشان می‌دهد.

این روشی است که
Bitcask
موتور ذخیره‌سازی پیش‌فرض
Riak
استفاده می‌کند.
در این سیستم، موتور باید قادر باشد تمام کلیدها را همزمان در حافظه اصلی نگه دارد.
از آن جا که عملیات نوشتن بدون جایگزینی است (فقط به انتهای فایل اضافه می‌کند)، به صورت دوره‌ای فایل‌ها را (داده‌ها در فایل‌های با سایز مشخص می‌نویسد و با رسیدن به سایز فایل دیگری آغاز می‌کند) از نو می‌نویسد (و اگر بتواند ترکیب می‌کند) و داده‌های تکراری خود به خود حذف می‌شوند.

چالش‌های پیاده‌سازی:
- فرمت فایل: باینری با یک رشته که طولش در ابتدا آمده
- حذف رکورد: نوشتن یک رکورد جدید tombstone
- بازیابی از کرش: خواندن دوباره‌ی همه‌ی فایل‌ها. اما در این پیاده‌سازی هش‌مپ هر فایل همراهش نوشته می‌شود که کار خواندن را ساده‌تر کند.
- رکوردهای نصفه نوشته شده:  چک‌سام هر فایل وجود دارد و با در نظر گرفتن آن می‌شود بعضی رکوردها را در نظر نگرفت
- کنترل اجرای همزمان: فقط یک ترد نویسنده وجود دارد

محدودیت‌های این نوع ایندکس:
- محدودیت حافظه: به رم محدود است
- پرس و جوهای بازه‌ای را پاسخگو نیست - range queries

### SSTables and LSM-Trees
SSTable: Sorted String Table

هر سگمنت را بر اساس کلید مرتب نگه‌می‌دارد که عملیات مرج را ساده می‌کند.

> ``📝`` در کتاب «نوشتن در سگمنت» را در انتها توضیح داده که برای من گیج‌کننده بود. توضیح را در ابتدا می‌آورم:

نوشتن در سگمنت:
- به جای
hash-map
در حافظه یک درخت بالانس شده مانند
red-black یا AVL
نگه می‌دارد: memtable
- وقتی حجم
memtable
به حد مشخصی رسید، آن را در یک فایل
SSTable
می‌نویسد. در حین نوشتن، نوشتن‌های جدید در یک
memtable
جدید ذخیره می‌شوند
- برای خواندن، ابتدا حافظه جستجو می‌شود، سپس اخیرترین سگمنت، بعد قبلی آن و به همین ترتیب
- گاه به گاه، پروسه‌ی مرج و فشرده‌سازی صورت می‌گیرد که سگمنت‌ها را ترکیب می‌کند و رکوردهای پاک شده را دور می‌ریزد
- برای اجتناب از گم شدن
memtable
در زمان کرش، رکوردها را در یک فایل لاگِ بدون ترتیب نوشته و هر زمان
memtable
در فایل نوشته شد فایل لاگ را پاک می‌کند.

مزایای
SSTable
نسبت به سگمنت‌هایی که از ایندکس
hash
استفاده می‌کنند:
- مرج آسان‌تر است
- برای یافتن رکوردی در فایل، نیاز به نگه‌داری همه‌ی کلید‌ها نیست. آدرس رکوردی نزدیک آن کافی‌ست که فایل را پیدا کند.
- در خواندن نیاز است چند رکورد نزدیک پیمایش شوند، پس می‌توان این رکوردها را در یک بلوک قرار داد و قبل از نوشتن رو دیسک فشرده کرد. این فشرده‌سازی در فضای دیسک و حجمِ نوشته/خوانده‌شده صرفه‌جویی می‌کند.

#### LSM-tree out of SSTables
LSM-Tree: log-structured merge-tree

الگوریتم‌های ذکر شده در
LevelDB و RocksDB
استفاده می‌شوند که کتاب‌خانه‌های موتورهای ذخیره‌ی 
key-value
هستند.

مثلا
LevelDB
را در
Riak
می‌توان به جای
Bitcask
استفاده کرد.

موتورهای ذخیره‌سازی مشابه در
Cassandra و HBase
استفاده می‌شوند.

این‌ها همه از مقاله‌ی
Bigtable
گوگل الهام گرفته‌اند که واژه‌های
SSTable و memtable
را معرفی کرد.

چنین ساختاری در
Lucene
که موتور ایندکسینگ
Elasticsearch و Solr
است استفاده می‌شود.

> **Note**: Lucene is _full-text search_ indexing engine.

#### Performance optimization

- با توجه به زمان زیادی که برای اعلام عدم موجودی یک کلید نیاز است، از ساختارهایی چون
[Bloom filter](https://en.wikipedia.org/wiki/Bloom_filter)
برای اعلام عدم وجود کلید استفاده می‌شود.
- استراتژی‌های مختلف برای فشرده‌سازی و مرج
SSTableها
به کار گرفته می‌شود. 

در کل
write throughput
در
LSM-Treeها
بسیار بالاست.

### B-Trees
رایج‌ترین ساختار برای ایندکس‌گذاری
B-Trees
هستند.

پایگاه داده را به بلوک‌های با طول ثابت (به صورت سنتی ۴ کیلوبایتی) می‌شکنند.
هر با یک صفحه را می‌نویسند یا می‌خوانند.
هر صفحه آدرسی برای دستیابی روی دیسک دارد و می‌تواند آدرس صفحات دیگری را نگه دارد.
یک صفحه‌ی
root
درخت را آغاز می‌کند و برگ‌های درخت بازه‌ای از کلیدها را ذخیره می‌کنند.
این بازه‌ها اشاره‌گرهایی به صفحه‌های دیگر (برگ) دارند که بتوان بازه را در آن‌ها نیز دنبال کرد.

به
branching factor
هم اشاره کرده.
معمولا چیزی حدود چندصد است.

این نوع درخت با شکستن صفحه‌ها رشد می‌کنند
و الگوریتم بالانس درخت را حفظ می‌کند.

مثال: یک درخت چهارسطحی با صفحات ۴ کیلوبایتی و فاکتور شاخه‌شاخه شدن ۵۰۰، می‌تواند تا ۲۵۰ ترابایت ذخیره کند.

#### Making B-trees reliable
اضافه کردن به یک صفحه یعنی تغییر آن در محلی که هست. این با ساختار
SSTable
متفاوت است که همه‌چیز فقط اضافه می‌شد.

اگر صفحه به خاطر افزودن یک کلید از سایز حد بیشتر شود و شکسته شود، اشاره‌گرهای والدین هم باید تصحیح شود.
در این حین اگر کرش اتفاق بیفتد داده‌ها ناسازگار خواهند بود.

برای حل، از
WAL (write-ahead log or redo log)
استفاده می‌شود.
هر چیزی قبل از نوشته شدن روی درخت، در این لاگ نوشته می‌شود و در بازیابی خطا، دوباره این تغییرات روی درخت اعمال می‌شود.

مشکل دیگر همزمانی در تغییر داده‌های درخت است، که برای حل با 
latches
(قفل‌های سبک)
از ساختار درخت محافظت می‌شود.

> ``📝`` در مورد بهینه‌سازی این نوع درخت هم پنج مورد اشاره کرده که خلاصه نکردم.

### B-Trees vs LSM-Trees
- سرعت نوشتن در
LSM-Trees
و سرعت خواندن از
B-Trees
بیشتر از دیگری است.

### Other indexing structures

## Transaction processing vs Analytics

### Data warehousing

### Stars, Snowflakes

## Column-oriented structures

### Column compression

### Sort order

### Writing

### Aggregation


[back](README.md)