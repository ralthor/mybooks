# فصل بیست و پنجم: لایه‌ها و مرزها

- می‌توان در سناریوهای ساده سیستم را متشکل از سه لایه در نظر گرفت
    - رابط کاربری
    - منطق تجاری
    - پایگاه داده
- اما در واقعیت تعداد لایه‌ها بیشتر از این‌هاست
- از بازی «شکار وامپوس» مثال زده و به تدریج معماری را با توجه به نیازها بزرگ‌تر کرده

- ابتدا فرض کرده که زبان‌های مختلفی را قرار است پشتیبانی کند

![38D1574A-11C2-4F6F-9725-72442739FCE9.jpeg](%D9%81%D8%B5%D9%84%20%D8%A8%DB%8C%D8%B3%D8%AA%20%D9%88%20%D9%BE%D9%86%D8%AC%D9%85%20%D9%84%D8%A7%DB%8C%D9%87%E2%80%8C%D9%87%D8%A7%20%D9%88%20%D9%85%D8%B1%D8%B2%D9%87%D8%A7%20950971a6e7614202bc0bc0266fc6bb0b/38D1574A-11C2-4F6F-9725-72442739FCE9.jpeg)

- بعد محل ذخیره‌سازی سیستم را متغیر فرض کرده
    - قرار نیست قوانین بازی چیزی از انواع ذخیره‌سازی بدانند

![0B18B30F-AFDF-4F2B-B031-002EA9340AA3.jpeg](%D9%81%D8%B5%D9%84%20%D8%A8%DB%8C%D8%B3%D8%AA%20%D9%88%20%D9%BE%D9%86%D8%AC%D9%85%20%D9%84%D8%A7%DB%8C%D9%87%E2%80%8C%D9%87%D8%A7%20%D9%88%20%D9%85%D8%B1%D8%B2%D9%87%D8%A7%20950971a6e7614202bc0bc0266fc6bb0b/0B18B30F-AFDF-4F2B-B031-002EA9340AA3.jpeg)

### معماری تمیز؟

- با این سوال شروع کرده
    - آیا تمام مرزهای مشخص معماری را پیدا کرده‌ایم؟
        - مرزهای مشخص معماری: significant architectural boundaries
- بعد امکانات مختلف را در نظر گرفته
    - ممکن است متن زبان‌های مورد استفاده‌ی بازی از منابع متفاوتی وارد شود
    - در شکل زیر، کلاس‌های نقطه‌چین کلاس‌های مجرد (یا اینترفیس) هستند که توسط کامپوننت وابسته پیاده‌سازی می‌شوند

![22D2B73F-C221-4C59-977F-2A5F18B08960.jpeg](%D9%81%D8%B5%D9%84%20%D8%A8%DB%8C%D8%B3%D8%AA%20%D9%88%20%D9%BE%D9%86%D8%AC%D9%85%20%D9%84%D8%A7%DB%8C%D9%87%E2%80%8C%D9%87%D8%A7%20%D9%88%20%D9%85%D8%B1%D8%B2%D9%87%D8%A7%20950971a6e7614202bc0bc0266fc6bb0b/22D2B73F-C221-4C59-977F-2A5F18B08960.jpeg)

- به کلاس‌های نقطه‌چین «اینترفیس پلی‌مورفیک مرزی» گفته
    - اینترفیس پلی‌مورفیک مرزی: polymorphic boundary interface
- این اینترفیس‌ها توسط کلاس بالادست (سطح بالا) تعریف می‌شوند
    - این کلاس است که می‌گوید چطور باید با آن حرف زد
- دیاگرام بالا را می‌توان با حذف گوناگونی‌های استفاده به صورت زیر درآورد

- جهت تمام اتصالات رو به بالاست که سیاست سطح بالا را در جایی که باید باشد (بالا) نشان دهد
    - سیاست سطح بالا: high-level policy
- دو جریان اصلی اینجا وجود دارد
    - جریان: stream
    - جریان بین کاربر و قوانین بازی
    - جریان میان قوانین بازی و ذخیره‌سازی
        - (ترتیب ذکر کامپوننت‌ها مهم نیست)
- هر دو جریان در قوانین بازی به هم می‌رسند

![A798EF5B-D12A-4D6E-8D4F-FDA9CBC46D6A.jpeg](%D9%81%D8%B5%D9%84%20%D8%A8%DB%8C%D8%B3%D8%AA%20%D9%88%20%D9%BE%D9%86%D8%AC%D9%85%20%D9%84%D8%A7%DB%8C%D9%87%E2%80%8C%D9%87%D8%A7%20%D9%88%20%D9%85%D8%B1%D8%B2%D9%87%D8%A7%20950971a6e7614202bc0bc0266fc6bb0b/A798EF5B-D12A-4D6E-8D4F-FDA9CBC46D6A.jpeg)

### گذشتن از جریان‌ها

- گذشتن از جریان‌ها: crossing the streams
- این‌طور نیست که همیشه فقط دو جریان داشته باشیم
- مثلا می‌توان شبکه را مانند شکل زیر اضافه کرد

![AEC1C049-E94C-452D-B781-441A9222EE7B.jpeg](%D9%81%D8%B5%D9%84%20%D8%A8%DB%8C%D8%B3%D8%AA%20%D9%88%20%D9%BE%D9%86%D8%AC%D9%85%20%D9%84%D8%A7%DB%8C%D9%87%E2%80%8C%D9%87%D8%A7%20%D9%88%20%D9%85%D8%B1%D8%B2%D9%87%D8%A7%20950971a6e7614202bc0bc0266fc6bb0b/AEC1C049-E94C-452D-B781-441A9222EE7B.jpeg)

### تفکیک جریان‌ها

- این طور نیست که همیشه همه‌ی جریان‌ها در بالادست به یک کامپوننت تکی برسند
- یک سری سیاست دیگر در سطحی باز هم بالاتر تعریف می‌کند که راجع به سلامت بازیکن تصمیم می‌گیرد
- ‫این سیاست‌ها «وضعیت» (state) بازیکن را نگه می‌دارند

![E4FC8FA5-AA7A-4D8F-96B9-AC876DA3BA93.jpeg](%D9%81%D8%B5%D9%84%20%D8%A8%DB%8C%D8%B3%D8%AA%20%D9%88%20%D9%BE%D9%86%D8%AC%D9%85%20%D9%84%D8%A7%DB%8C%D9%87%E2%80%8C%D9%87%D8%A7%20%D9%88%20%D9%85%D8%B1%D8%B2%D9%87%D8%A7%20950971a6e7614202bc0bc0266fc6bb0b/E4FC8FA5-AA7A-4D8F-96B9-AC876DA3BA93.jpeg)

- ‫آیا نیاز به API داریم که مدیریت حرکت را از مدیریت بازیکن جدا کنیم؟
- این کار را با میکروسرویس انجام داده
- فرض کرده که مدیریت حرکت در کامپیوتر محلی (لوکال) کاربر انجام می‌شود اما مدیریت بازیکن توسط‫ سروری انجام می‌شود به تمام کامپوننت‌های «مدیریت حرکت» API میکروسرویس ارائه می‌دهد

![4030966B-AF2B-4564-87E1-CBEE77D639A1.jpeg](%D9%81%D8%B5%D9%84%20%D8%A8%DB%8C%D8%B3%D8%AA%20%D9%88%20%D9%BE%D9%86%D8%AC%D9%85%20%D9%84%D8%A7%DB%8C%D9%87%E2%80%8C%D9%87%D8%A7%20%D9%88%20%D9%85%D8%B1%D8%B2%D9%87%D8%A7%20950971a6e7614202bc0bc0266fc6bb0b/4030966B-AF2B-4564-87E1-CBEE77D639A1.jpeg)

### نتیجه‌گیری

- هدف مثال بالا نمایش این بود که
    - مرزهای معماری همه‌جا وجود دارند
    - ما به عنوان معمار باید آن‌ها را هر جا که نیاز بودند تشخیص دهیم
    - باید همچنین بدانیم که این مرزها وقتی به طور کامل پیاده‌سازی می‌شوند هزینه‌بر هستند
    - با این وجود، باید تشخیص دهیم که اگر به این مرزها بی‌اعتنا باشیم، باید بعدا هزینه‌ی بسیار زیادی برای اضافه کردنشان صرف کنیم
        - حتی اگر تست و ریفکتورینگ هم حضور داشته باشند
- تصمیمات معماری تصمیمات «فقط یک باره» نیستند
    - باید در چرخه‌ی زندگی سیستم مدام به معماری توجه داشت و آن را تغییر داد