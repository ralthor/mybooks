# فصل چهاردهم: جفت‌شدگی کامپوننت

سه اصل دیگر اینجا گفته

باز هم بحث روی قابلیت توسعه و طراحی منطقی هست

- اصل وابستگی‌های بدون دور  ADP
    
    مربوط به وقتی است که همه تیم تلاش می‌کنند به تغییرات یکدیگر واکنش دهند و کد خود را برای کار با تغییرات بقیه مدام تغییر دهند
    
    دو راهکار برای رفع این مشکل 
    
    - بیلد هفتگی
        
        برای پروژه‌های متوسط 
        
        چهار روز اول هفته بدون توجه به تغییرات یکدیگر 
        
        روز آخر هفته تجمیع تغییرات و بیلد سیستم 
        
        برای پروژه‌های بزرگ در یک روز نمی‌شود تجمیع کرد 
        
        پس دوهفته‌ای می‌شود اما آن هم در دراز مدت روزهای تجمیع بیشتری می‌خواهد و در نهایت تیم مزیت فیدبک سریع چهار روزه که در ابتدا داشت از دست داده است 
        
    - از بین بردن چرخه‌های وابستگی
        
        تقسیم محیط توسعه به کامپوننت‌های قابل ریلیز 
        
        هر کامپوننت یک تیم یا توسعه‌دهنده منحصر به خود دارد که از سایر کامپوننت‌ها استفاده می‌کنند و/یا برای سایرین کامپوننت می‌سازند 
        
        این که از کدام ورژن استفاده کنند در اختیار خودشان است 
        
        به تدریج ورژن‌های جدید استفاده می‌شوند 
        
        برای این که این سیستم کار کند، نیاز است که چرخه‌ای در ساختار وابستگی‌ها نباشد.
        
        - راه حل‌ها
            
            مثال 
            
            ![DCE303E7-9E85-4029-9969-46D4F050D6DE.jpeg](%D9%81%D8%B5%D9%84%20%DA%86%D9%87%D8%A7%D8%B1%D8%AF%D9%87%D9%85%20%D8%AC%D9%81%D8%AA%E2%80%8C%D8%B4%D8%AF%DA%AF%DB%8C%20%DA%A9%D8%A7%D9%85%D9%BE%D9%88%D9%86%D9%86%D8%AA%20ea35d9d25c0342dd97024de61a135d28/DCE303E7-9E85-4029-9969-46D4F050D6DE.jpeg)
            
            یک. وابستگی معکوس 
            
            ![FA8C6996-4151-4207-B4B3-BAAA8CD0FC78.jpeg](%D9%81%D8%B5%D9%84%20%DA%86%D9%87%D8%A7%D8%B1%D8%AF%D9%87%D9%85%20%D8%AC%D9%81%D8%AA%E2%80%8C%D8%B4%D8%AF%DA%AF%DB%8C%20%DA%A9%D8%A7%D9%85%D9%BE%D9%88%D9%86%D9%86%D8%AA%20ea35d9d25c0342dd97024de61a135d28/FA8C6996-4151-4207-B4B3-BAAA8CD0FC78.jpeg)
            
            دو. کامپوننت جدید 
            
            ![12F39F83-2C54-4594-AD47-69AB6F697D03.jpeg](%D9%81%D8%B5%D9%84%20%DA%86%D9%87%D8%A7%D8%B1%D8%AF%D9%87%D9%85%20%D8%AC%D9%81%D8%AA%E2%80%8C%D8%B4%D8%AF%DA%AF%DB%8C%20%DA%A9%D8%A7%D9%85%D9%BE%D9%88%D9%86%D9%86%D8%AA%20ea35d9d25c0342dd97024de61a135d28/12F39F83-2C54-4594-AD47-69AB6F697D03.jpeg)
            
        
    
    با رشد برنامه، ساختار وابستگی کامپوننت هم دچار تغییر می‌شود.
    
    این تغییرات همیشه باید مانیتور شوند که شامل چرخه نباشند 
    
    در صورت وجود چرخه، با ایجاد کلاس‌ها یا کامپوننت‌های جدید آن را از بین می‌بریم
    
- طراحی بالا به پایین
    
    تا اینجا می‌شود نتیجه گرفت: ساختار کامپوننت را نمی‌توان از بالا به پایین طراحی کرد
    
    - در واقع دیاگرام وابستگی کامپوننت توصیف معتبری از کارایی اپلی‍کیشن نیست، بلکه نگاشتی به تولیدپذیری و قابلیت نگه‌داری اپلیکیشن است
        - تولیدپذیری: buildability
        - قابلیت نگه‌داری: maintainability
    - این دو قابلیت در ابتدای پروژه وجود نداشته‌اند (پروژه‌ای که وجود ندارد تولیدپذیری و قابلیت نگه‌داری ندارد) پس نگاشتی هم وجود نداشته
    
    یکی از دغدغه‌ها در ساختار وابستگی، محدود کردن فرّارهاست
    
    - فرّار: volatility
    - نمی‌خواهیم کامپوننت‌هایی که مرتبا تغییر می‌کنند روی کامپوننت‌هایی را که به خودی خود پایدار هستند تاثیر بگذارند
    - اگر پیش از طراحی کلاس‌ها سعی در طراحی ساختار کامپوننت کنیم احتمالا به بی‌راهه می‌رویم
        - ‫چون هنوز راجع به common closure و عناصر reusable آگاه نیستیم
- اصل وابستگی‌های پایدار SDP
    - اگر قرار بر حفظ طراحی است، میزانی از فرّاری لازم است
    - کامپوننت‌های فرّار نباید وابستگی کامپوننت‌های پایدار باشند، در غیر این صورت تغییر آن‌ها مشکل خواهد بود
    
    ### پایداری
    
    هر کامپوننتی که تعداد زیادی وابستگی ورودی داشته باشد (یعنی زیاد به آن وابسته باشند) بسیار پایدار است چون هر تغییری در آن باید به وابستگی‌هایش هم اعمال شود
    
    ### معیارهای پایداری
    
    ‫معیار instability (ناپایداری) که با i نمایش داده:
    
    i = fanout / (fanin + fanout)
    
    تعداد خروجی‌ها (وابستگی به سایر کامپوننت‌ها)، تقسیم بر تعداد کل وابستگی‌ها (شامل ورودی و خروجی)
    
    عددی بین صفر و یک
    
    هر چه به صفر نزدیک‌تر، یعنی بقیه بیشتر به این کامپوننت وابسته‌اند: کامپوننت پایدارتر است
    
    هر چه به یک نزدیک‌تر، یعنی این کامپوننت بیشتر به بقیه وابسته است: کامپوننت ناپایدارتر است
    
    ‫اصل SDP میگوید:
    
    - ‫معیار i باید در جهت وابستگی کاهش یابد
        - یعنی کامپوننت‌های ناپایدار به پایدارها وابسته باشند، نه برعکس
    
    ### همه‌ی کامپوننت‌ها نباید پایدار باشند
    
    باز هم اگر نیاز به وابستگی یک کامپوننت پایدار به یک کامپوننت منعطف باشد، از وارونگی وابستگی استفاده کرده و جهت وابستگی را تغییر می‌دهیم
    
    مثال 
    
    ![image.jpg](%D9%81%D8%B5%D9%84%20%DA%86%D9%87%D8%A7%D8%B1%D8%AF%D9%87%D9%85%20%D8%AC%D9%81%D8%AA%E2%80%8C%D8%B4%D8%AF%DA%AF%DB%8C%20%DA%A9%D8%A7%D9%85%D9%BE%D9%88%D9%86%D9%86%D8%AA%20ea35d9d25c0342dd97024de61a135d28/image.jpg)
    
- اصل تجریدهای پایدار SAP
    - رابطه‌ای میان پایداری و تجرید ایجاد می‌کند
    - کامپوننت‌های پایدار باید مجرد باشند که پایداری منجر به عدم گسترش آن‌ها نشود
    - ‫کامپوننت‌های غیرپایدار باید concrete باشند که بشود کد داخل آن‌ها را به راحتی تغییر داد
    - اگر کامپوننتی قرار است پایدار باشد، باید اینترفیس‌ها و کلاس‌های مجردی برای ایجاد قابلیت گسترش داشته باشد
    - از آن جا که وابستگی در جهت پایداری حرکت می‌کند و این جا گفته شد پایدارها باید مجرد باشند، پس
        - وابستگی در جهت تجرید حرکت می‌کند
    
    ### اندازه‌گیری تجرید
    
    ‫متریک A تجرید یک کامپوننت را نشان می‌دهد
    
    - تعداد کلاس‌های مجرد تقسیم بر تعداد همه‌ی کلاس‌های یک کامپوننت
    - معیاری بین صفر و یک است
    - صفر یعنی بدون کلاس مجرد
    - یک یعنی تمام کلاس‌های کامپوننت مجرد هستند
    
    ### ‫ارتباط i و A
    
    ‫ارتباط تجرید و پایداری را در گراف I/A نشان داده
    
    ![01DEFC6C-63AB-4114-A4CA-4682CE098813.jpeg](%D9%81%D8%B5%D9%84%20%DA%86%D9%87%D8%A7%D8%B1%D8%AF%D9%87%D9%85%20%D8%AC%D9%81%D8%AA%E2%80%8C%D8%B4%D8%AF%DA%AF%DB%8C%20%DA%A9%D8%A7%D9%85%D9%BE%D9%88%D9%86%D9%86%D8%AA%20ea35d9d25c0342dd97024de61a135d28/01DEFC6C-63AB-4114-A4CA-4682CE098813.jpeg)
    
    منطقه‌های بی‌استفاده و عذاب هم در شکل نشان داده شده
    
    - منطقه‌ی بی‌استفاده کامپوننت‌هایی را نشان می‌دهد که با وجود تجرید بالا، وابستگی سایر کامپوننت‌ها نیستند
    - منطقه‌ی عذاب کامپوننت‌هایی با تجرید پایین، اما پایدارند (سایر کامپوننت‌ها وابسته به ‌آن‌ها هستند) که گسترش آن‌ها سخت است
    
    ![image.png](%D9%81%D8%B5%D9%84%20%DA%86%D9%87%D8%A7%D8%B1%D8%AF%D9%87%D9%85%20%D8%AC%D9%81%D8%AA%E2%80%8C%D8%B4%D8%AF%DA%AF%DB%8C%20%DA%A9%D8%A7%D9%85%D9%BE%D9%88%D9%86%D9%86%D8%AA%20ea35d9d25c0342dd97024de61a135d28/image.png)
    
    ‫برای اجتناب از نواحی عذاب و بی‌استفاده، معیار دیگری تعریف شده که فاصله از خط main sequence را نشان می‌دهد
    
    D = |A+i-1|
    
    - بازه‌ی این معیار هم صفر و یک است.
    - صفر یعنی کامپوننت روی خط است
    - یک یعنی کامپوننت در دورترین فاصله از خط است
    
    ‫به عنوان یک معیار کنترل کامپوننت یک فاصله‌ی حدی از main sequence تعریف کرده و اگر کامپوننت در یکی از ریلیزها از این معیار فراتر رفت آن را بررسی و احتمالا refactor یا redesign می‌کند
    
    حدی که در مثال گفته 0.1 است