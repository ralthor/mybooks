# 🚧فصل سوم. ذخیره و بازیابی
هدف نوشتن در پایگاه داده و سپس بازیابی اطلاعات است.

## Data structures for Databases
یک مثال ساده از یک بانک اطلاعاتی زده:
- ذخیره: اضافه به انتهای یک فایل - داده جدید جایگزین نمی‌شود بلکه فقط اضافه می‌شود.
- ‫بازیابی: استفاده از دستور grep برای کلید

کارایی نوشتن بسیار بالاست. در پایگاه‌های داده چیزی به نام
log
برای نوشتن استفاده می‌شود که به همین صورت کار می‌کند.

اما کارایی خواندن وقتی داده زیاد باشد بسیار پایین است.
برای بهبود زمان خواندن، از ایندکسینگ استفاده می‌کنیم.

ایندکس داده‌ای اضافه و به دست آمده از داده‌ی اصلی است.

ایندکس‌ها زمان نوشتن را بیشتر می‌کنند، و به صورت پیش‌فرض اعمال نمی‌شوند. توسعه‌دهنده‌ی سیستم باید فیلد(هایی) که ایندکس لازم دارند معرفی کند.

### Hash indexes
از ساختار
hash-map
که در زبان‌های برنامه‌نویسی پشتیبانی می‌شود استفاده می‌کند.
یک
hash-map
در حافظه‌ی اصلی برنامه کلید‌ها را نگه می‌دارد و هر کلید مکان رکورد در فایل را نشان می‌دهد.

این روشی است که
Bitcask
موتور ذخیره‌سازی پیش‌فرض
Riak
استفاده می‌کند.
در این سیستم، موتور باید قادر باشد تمام کلیدها را همزمان در حافظه اصلی نگه دارد.
از آن جا که عملیات نوشتن بدون جایگزینی است (فقط به انتهای فایل اضافه می‌کند)، به صورت دوره‌ای فایل‌ها را (داده‌ها در فایل‌های با سایز مشخص می‌نویسد و با رسیدن به سایز فایل دیگری آغاز می‌کند) از نو می‌نویسد (و اگر بتواند ترکیب می‌کند) و داده‌های تکراری خود به خود حذف می‌شوند.

چالش‌های پیاده‌سازی:
- فرمت فایل: باینری با یک رشته که طولش در ابتدا آمده
- حذف رکورد: نوشتن یک رکورد جدید tombstone
- بازیابی از کرش: خواندن دوباره‌ی همه‌ی فایل‌ها. اما در این پیاده‌سازی هش‌مپ هر فایل همراهش نوشته می‌شود که کار خواندن را ساده‌تر کند.
- رکوردهای نصفه نوشته شده:  چک‌سام هر فایل وجود دارد و با در نظر گرفتن آن می‌شود بعضی رکوردها را در نظر نگرفت
- کنترل اجرای همزمان: فقط یک ترد نویسنده وجود دارد

محدودیت‌های این نوع ایندکس:
- محدودیت حافظه: به رم محدود است
- پرس و جوهای بازه‌ای را پاسخگو نیست - range queries

### SSTables and LSM-Trees
SSTable: Sorted String Table

هر سگمنت را بر اساس کلید مرتب نگه‌می‌دارد که عملیات مرج را ساده می‌کند.

> ``📝`` در کتاب نوشتن در سگمنت را در انتها توضیح داده که برای من گیج‌کننده بود. توضیح را در ابتدا می‌آورم:

نوشتن در سگمنت:
- به جای
hash-map
در حافظه یک درخت بالانس شده مانند
red-black یا AVL
نگه می‌دارد: memtable
- وقتی حجم
memtable
به حد مشخصی رسید، آن را در یک فایل
SSTable
می‌نویسد. در حین نوشتن، نوشتن‌های جدید در یک
memtable
جدید ذخیره می‌شوند
- برای خواندن، ابتدا حافظه جستجو می‌شود، سپس اخیرترین سگمنت، بعد قبلی آن و به همین ترتیب
- گاه به گاه، پروسه‌ی مرج و فشرده‌سازی صورت می‌گیرد که سگمنت‌ها را ترکیب می‌کند و رکوردهای پاک شده را دور می‌ریزد
- برای اجتناب از گم شدن
memtable
در زمان کرش، رکوردها را در یک فایل لاگِ بدون ترتیب نوشته و هر زمان
memtable
در فایل نوشته شد فایل لاگ را پاک می‌کند.

مزایای
SSTable
نسبت به سگمنت‌هایی که از ایندکس هش استفاده می‌کنند:
- مرج آسان‌تر است
- برای یافتن رکوردی در فایل، نیاز به نگه‌داری همه‌ی کلید‌ها نیست. آدرس رکوردی نزدیک آن کافی‌ست که فایل را پیدا کند.
- در خواندن نیاز است چند رکورد نزدیک پیمایش شوند، پس می‌توان این رکوردها را در یک بلوک قرار داد و قبل از نوشتن رو دیسک فشرده کرد. این فشرده‌سازی در فضای دیسک و حجمِ نوشته/خوانده‌شده صرفه‌جویی می‌کند.


### B-Trees

### B-Trees vs LSM-Trees

### Other indexing structures

## Transaction processing vs Analytics

### Data warehousing

### Stars, Snowflakes

## Column-oriented structures

### Column compression

### Sort order

### Writing

### Aggregation


[back](README.md)