# 🚧فصل چهارم. ‫کدگذاری و Evolution
راجع به
forward- and backward-compatibility
در داده‌ها صحبت کرده.

تغییر در برنامه منجر به تغییر در داده هم می‌شود.

کد جدید با داده‌ی قدیمی 
(backward-compatibility)
و کد قدیمی با داده‌های جدید
(forward-compatibility)
بتوانند کار کنند

حتی در برنامه‌های سمت سرور هم تغییرات مرحله‌ای اعمال می‌شوند که منجر به کار با داده‌های قدیمی‌تر یا جدیدتر می‌شود.

> **ℹ️** در این فصل چند فرمت ذخیره‌سازی ذکر کرده و برای هر کدام روش برخورد با موارد بالا، اسکیما و روش استفاده در انتقال اطلاعات را بررسی کرده.

## Formats for Encoding Data
دو نوع نمایش لازم است:
- در حافظه
- در فایل

به نوعی ترجمه بین دو حالت بالا نیاز است.
- coding & encoding

### Language-Specific Formats
روش‌های مختص زبان‌های برنامه‌نویسی مثل
pickle
در
Python،
یا
Serializable
در
Java
و
Marshal
در
Ruby.

مشکلات:
- در زبان‌های دیگر سخت خوانده می‌شوند
- مشکلات امنیتی به خاطر احتمال وجود کد اجرایی یا دسترسی به حافظه
- ورژنینگ
- کارایی

در کل ایده‌ی بدی است.

### JSON, XML and Binary Variants
فرمت‌های ذخیره‌سازی
JSON, XML و CSV
هم مشکلات خودشان را دارند:
- ابهام در ذخیره‌ی اعداد
- عدم پشتیبانی باینری - نیاز به راهکارهایی مثل
base64
هست که حجم داده‌ها را تا ۳۳ درصد بیشتر می‌کند
- پشتیبانی اسکیما اختیاری، قوی اما پیچیده برای یادگیری و پیاده‌سازی است
- CSV
اسکیما ندارد و فرمت سطر و ستون هم در آن اختیاری است و بسیاری از پارسرها هم قوانین
scaping
را به درستی برای آن پیاده نکرده‌اند.

با وجود این مشکلات به اندازه‌ی کافی خوب هستند که تا مدت زیادی قابل استفاده باقی بمانند.

فرمت‌های زیادی برای ذخیره‌ی باینری
XML و JSON
پیاده‌سازی شده‌اند.

- JSON: MessagePack, BSON, BJSON, UBJSON, BISON, Smile
- XML: WBXML, Fast Infoset

### Thrift and Protocol Buffers


### Avro
### The Merits of Schemas

## Models of Dataflow
### Dataflow Through Databases
### Dataflow Through Services: Rest and RPC
### Message-Passing Dataflow

[back](README.md)