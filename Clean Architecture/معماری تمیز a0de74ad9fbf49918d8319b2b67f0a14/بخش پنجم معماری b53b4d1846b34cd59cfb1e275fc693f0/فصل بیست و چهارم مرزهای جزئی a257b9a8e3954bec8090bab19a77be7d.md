# فصل بیست و چهارم: مرزهای جزئی

- ایجاد مرز هزینه دارد
    - ورژنینگ
    - کامپایل و دیپلوی جداگانه
    - سربار پروتکل‌های صحبت بین کامپوننت‌ها
- وقتی هنوز در شروع کار هستیم و نمی‌دانیم آیا قرار است قسمتی از طراحی یک کامپوننت جدا باشد یا نه، به جای ساخت یک کامپوننت جدا از یک «مرز جزئی» استفاده می‌کنیم
    - تا با ایجاد کامپوننت مجزا هزینه‌ای به سیستم تحمیل نکنیم
    - این مرز جزئی ممکن است بعدا در صورت نیاز به تفکیک تبدیل شود
    - تا زمانی که چنین احتمالی وجود دارد، باید توجه داشت که مرز جزئی از بین نرود و وابستگی میان کلاس‌ها به حد غیرقابل تفکیک نرسد
- سه روش برای ساخت مرز جزئی مثال زده و در انتها گفته که روش‌های بی‌شماری برای این کار هست
    - اجتناب از مرحله‌ی آخر
        - از دو روش دیگر بیشتر به ایجاد کامپوننت جدید نزدیک است
        
        تمام کارهای لازم برای ایجاد مرز را انجام می‌دهد فقط گام جداسازی در یک کامپوننت دیگر را انجام نمی‌دهد
        
    - مرزهای یک بُعدی
        - از چیزی مانند الگوی استراتژی استفاده می‌کند
        - همچنان اصل وارونگی وابستگی برقرار است
        - یک اینترفیس (همان کلاس مجرد) داریم و کلاس وابسته از آن ارث‌بری می‌کند
        - در صورت عدم رعایت دلایل مرزبندی، ممکن است درخواست‌های کلاس وابسته به تدرج روی کلاس مستقل اعمال شود و مرز جزئی کم‌رنگ‌تر شود
    - استفاده از الگوی نما
        - Facade design pattern
            - [https://fa.wikipedia.org/wiki/الگوی_نما](https://fa.wikipedia.org/wiki/%D8%A7%D9%84%DA%AF%D9%88%DB%8C_%D9%86%D9%85%D8%A7)
        - اینجا حتی اصل وارونگی وابستگی هم فدا می‌شود
        - از دو روش قبلی مرز سست‌تری ایجاد می‌کند
        - مرز توسط کلاس «نما» ایجاد می‌شود
        - این کلاس به فراخوانی‌های سرویس دسترسی دارد که قرار است توسط استفاده‌کننده از کلاس «نما» دیده نشوند