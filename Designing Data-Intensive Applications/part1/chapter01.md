# 🚧فصل اول. برنامه‌های قابل اطمینان، مقیاس‌پذیر و قابل نگه‌داری

### کاربری یک سیستم داده‌محور
- ذخیره داده - پایگاه داده
- ‫به یاد سپردن نتیجه‌ی یک پردازش گران - cache
- اجازه به کاربران برای جستجو یا فیلتر داده‌ها - ایندکس
- ‫ارسال پیام به پردازه‌ی دیگر، که به صورت آسینکرون دریافت شود - پردازش جریانی stream processing
- مصرف دوره‌ای حجم زیادی داده‌ی جمع شده - پردازش دسته‌ای

> **_توجه:_ در فصل‌های بعد راجع به تصمیمات طراحی که باید در کار با کاربردهای داده‌محور لحاظ شوند صحبت خواهد شد**

‫برای مثال کدام پایگاه داده یا سیستم cache یا ایندکسینگ و از این دست


در مورد سه موضوع زیر صحبت کرده و تعریف کرده
- قابلیت اطمینان reliability
- مقیاس‌پذیری scalability
- قابلیت نگهداری maintainability

## قابلیت اطمینان
- قابلیت تحمل اشکالات سخت‌افزاری و نرم‌افزاری و خطاهای انسانی

برای هر کدام از این‌ها توضیح داده که چطور تلاش کنیم اشکالات رو کمتر کنیم.

### اشکالات سخت‌افزاری
مثلا برای اشکالات سخت‌افزاری، «چشم‌پوشی» صحیح نیست چون حتی برای هارددیسک‌هایی که قابلیت تحمل خطای بالا دارند وقتی در تعداد زیاد استفاده می‌شوند شانس ایجاد اشکال بسیار بیشتر می‌شود. برای این کار یک سری خطاهای مصنوعی در سیستم ایجاد می‌کنیم که مطمئن بشیم همه برای وقوع خطا آماده هستند.

### اشکالات نرم‌افزاری
برای خطاهای نرم‌افزاری در مقایسه با اشکالات سخت‌افزار، اشکال به صورت پخش در سیستم اتفاق می‌افته و مثلا ناگهان یک کامپوننت سیستم کامل از کار می‌افته که کل سیستم رو از کار می‌اندازه.

پیشنهاد می‌کنه
- شرایط بروز خطا از قبل بررسی بشه
- تست جامع
- جداسازی پردازه‌ها
- اجازه به پردازه‌ها که کرش کنند و ری‌استارت بشوند
- اندازه‌گیری، مانیتور و آنالیز رفتار سیستم در پروداکشن

مثلا در یک صف پیام، تعداد پیام‌های ورودی و خروجی یکی باشند در غیر این صورت آلارم بدهد

### خطاهای انسانی
حجم بالایی از خطاهای ایجاد شده در سیستم منشاء انسانی دارند، مثلا خطا در کانفیگ و از این دست. برای جلوگیری از این‌ها پیشنهاد می‌کنه که
- رابط‌های کاربری امکان ایجاد خطا رو حداقل کنند
- قسمت‌های خطاخیز از قسمت‌هایی که منجر به خطا می‌شوند تفکیک (دیکاپل) شوند
- تست جامع
- فراهم آوردن امکان ریکاوری سریع و آسان، برای مثال امکان رول‌بک سریع کانفیگی که به خطا خورده
- مانیتورینگ شفاف و با جزئیات
- آموزش


## مقیاس‌پذیری
در خلال رشد سیستم (در حجم داده، ترافیک، یا پیچیدگی) باید روش‌های معقولی برای کنار آمدن با این رشد وجود داشته باشد

‫روشی که توییتر برای سرعت لود بیشتر صفحه‌ی home کاربران انجام داده و روش fan-out و ترکیبش با روش سنتی برای لود توییت‌های سلبریتی‌ها رو توضیح داده

### اندازه‌گیری بار و کارایی
چطور به قضیه‌ی افزایش بار سیستم نگاه کنیم
- وقتی یک پارامتر لود را افزایش می‌دهیم و منابع سیستم را ثابت نگه می‌داریم کارایی چطور تغییر می‌کند
- وقتی یک پارامتر بار را افزایش می‌دهیم چطور منابع سیستم را افزایش دهیم که کارایی ثابت بماند

هر دو این سوال‌ها، نیازمند «اعداد کارایی» هستند

- صدک‌های تاخیر: بهتر از «متوسط» هستند، چون درخواست‌ها را دسته‌بندی می‌کنند. مثلا صدک ۹۷ برابر ۳۰۰ میلی‌ثانیه نشان می‌دهد ۹۷ درصد درخواست‌ها حداقل در ۳۰۰ میلی‌ثانیه پاسخ داده شده‌اند

tail latency amplification: وقتی چند پروسه‌ی همزمان برای یک درخواست کاربر اجرا می‌شوند و پاسخ به کاربر نیازمند پاسخ تمام این پردازه‌هاست، پاسخ به این درخواست به اندازه‌ی کندترین پردازه طول خواهد کشید

### رویکردهایی برای کنار آمدن با بار
‫روش‌های scale up و scale down رو گفته که اولی مهاجرت به یک ماشین قوی‌تر و دومی توزیع بار روی چند ماشین کوچک‌تر هست.

‫در مورد سیستم‌های elastic هم صحبت کرده که وقتی افزایش بار تشخیص بدهند منابع محاسباتی رو خودکار به سیستم اضافه می‌کنند و به درد سیستم‌هایی می‌خورند که بار غیرقابل پیشبینی دارند.

در مورد «معماری» سیستم صحبت کرده: حول فرضیاتی شکل می‌گیره چه عملیاتی مرسوم و چه عملیاتی به ندرت در سیستم اتفاق می‌افتند.
مهندسی عملیات نادر هدر دادن زمان و هزینه است.

هر چند معماری‌های مقیاس‌پذیر برای کاربردهای مخصوص به خود ساخته می‌شوند، اما معمولا از قطعات همه‌منظوره ساخته می‌شوند و از الگوهای مشترکی استفاده می‌کنند.

## قابلیت نگهداری
### عملیات‌پذیری operability
آسان‌سازی کار برای تیم عملیات که سیستم را به آسانی راهبری کنند. کار تیم عملیات:
- مانیتورینگ سلامت سیستم و توانایی بازیابی سریع وضعیت در صورت اشکال
- یافتن علت مشکلات
- به‌روز نگه داشتن نرم‌افزارها و پلتفرم‌ها شامل پچ‌های امنیتی
- مانیتور سیستم‌های مختلف برای جلوگیری از تاثیر بر یکدیگر، تا مشکلاتشان به هم سرایت نکند
- پیشبینی و حل مشکلات آینده قبل از وقوع - مثلا برنامه‌ریزی ظرفیت
- پیاده‌سازی ابزارهای مناسب برای دپلوی، مدیریت کانفیگ و از این دست
- انجام کارهای نگه‌داری پیچیده مانند انتفال کاربرد از پلتفرمی به پلتفرم دیگر
- نگه‌داری از امنیت سیستم در خلال تغییر کانفیگ
- ‫تعریف پردازه‌هایی که عملیات را قابل پیشبینی می‌کنند و محیط پروداکشن را stable نگه می‌دارند
- حفظ و نگه‌داری از دانش سیستم حتی اگر تغییر نیروی انسانی اتفاق بی‌افتد

روش‌های مختلفی که کارهای روتین را برای سیستم‌های داده‌ای آسان کنیم:

- ‫visibility از طریق مانیتورینگ خوب
- اتوماسیون و یکپارچه سازی با ابزارهای استاندارد
- جلوگیری از وابستگی دستگاه ها
- ارائه مستندات روشن و مدل عملیاتی
- ارائه رفتار پیش فرض خوب با گزینه‌های مدیریتی قابل تنظیم
- ارائه‌ی خودترمیمی با کنترل دستی
- نمایش رفتار قابل پیش بینی و کمینه کردن سورپرایز

### سادگی
با رشد پروژه ها، درک آن ها پیچیده و دشوار می شود.
کاهش پیچیدگی، قابلیت نگهداری را بهبود می بخشد و باید هدف طراحی باشد.

**پیچیدگی تصادفی**
پیچیدگی تصادفی است اگر ناشی از انتخاب های ضعیف طراحی یا پیاده سازی باشد،
نه ناشی از ماهیت ذاتی مشکلی که نرم افزار قصد حل آن را دارد.

می‌توان از این نوع پیچیدگی با طراحی و پیاده سازی دقیق نرم افزار اجتناب کرد.

**مجردسازی**
ابزاری برای اجتناب از پیچیدگی تصادفی.

### قبلیت گسترش evolvability
‫برای طراحی‌های معمولی، از مدل agile برای وفق با تغییرات استفاده می‌کنیم.

اما این مدل برای ریفکتور کردن طراحی توییتر که مثال زده شده (در کتاب) مناسب نیست.

اینجا مجردسازی به کمک می‌آید. سیستم‌های ساده و قابل فهم را معمولا می‌شود راحت‌تر تغییر داد.


[back](README.md)