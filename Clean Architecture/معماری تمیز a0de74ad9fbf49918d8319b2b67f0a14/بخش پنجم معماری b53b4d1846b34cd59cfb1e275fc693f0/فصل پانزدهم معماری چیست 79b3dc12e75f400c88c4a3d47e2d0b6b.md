# فصل پانزدهم: معماری چیست

- معمار نرم‌افزار به انجام وظایف برنامه‌نویسی ادامه می‌دهد تا همچنان در معرض مشکلاتی که برای تیم توسعه ایجاد می‌کند باشد
- شکل معماری نرم‌افزار برای آسان‌سازی توسعه، دپلوی و نگه‌داری سیستم نرم‌افزاری است
- استراتژی پشت این آسان‌سازی، باز گذاشتن هر چه بیشتر گزینه‌های ممکن، تا هر زمانِ ممکن است
- هدف اصلی معماری پشتیبانی از چرخه‌ی نرم‌افزار سیستم است.
- معماری خوب،
    - آسان درک می‌شود
    - آسان دپلوی می‌شود
    - آسان نگه‌داری می‌شود
- هدف نهایی، کمینه‌سازی هزینه‌ی تمام چرخه‌ی حیات سیستم و بیشینه‌سازی کارایی برنامه‌نویس است

### توسعه

- ساختارهای متفاوت تیمی تصمیمات معماری متفاوت را اقتضا می‌کنند
    - یک تیم پنج نفره به راحتی یک نرم‌افزار مونولیت را توسعه می‌دهند
        - در این حالت نیاز به تعریف دقیقی از ساختار کامپوننت‌های سیستم نیست
    - در سوی دیگر، سیستمی که توسط پنج تیم هفت نفره توسعه داده می‌شود بدون ساختار دقیق کامپوننت و اینترفیس‌های قابل اطمینان و پایدار، جلو نمی‌رود

### دپلوی

- هر چه هزینه‌ی دپلوی سیستم بالاتر باشد، سیستم کمتر قابل استفاده است

### عملکرد

- اثر معماری روی عملکرد سیستم کمتر از اثر آن روی توسعه، دپلوی و نگه‌داری است
- این اصل که سخت‌افزار ارزان است و نیروی انسانی گران، به این معنی است که
    - معماری که سخت‌افزار را تحت فشار می‌گذارد اثر هزینه‌ای کمتر از معماری دارد که توسعه، دپلوی و نگه‌داری را سخت‌تر می‌کند

### نگه‌داری

- نگه‌داری هزینه‌برترین جنبه‌ی یک سیستم نرم‌افزاری است
- ‫اصطلاح spelunking را برای اکتشاف در نرم‌افزار موجود و تلاش برای یافتن بهترین مکان و استراتژی برای افزودن یک فیچر جدید به کار برده

### باز گذاشتن گزینه‌ها

- نرم‌افزار دو ارزش دارد
    - ارزش رفتاری
    - ارزش ساختاری
- ارزش دومی از اولی بیشتر است

- روشی که نرم‌افزار را نرم نگه می‌داریم این است که گزینه‌های بیشتری را برای مدت بیشتری باز نگه می‌داریم
    - چیزهایی که انتخاب آن‌ها را برای بعد می‌گذاریم جزئیاتی هستند که الان اهمیت ندارند
    - بعدا مثال‌های بیشتری از این گزینه‌ها ارائه می‌کند
- هر سیستم نرم‌افزاری به دو عنصر تجزیه‌پذیر است
    - سیاست policy پالیسی
    - جزئیات details
- ارزش اصلی سیستم پالیسی است
    - برای مثال موتور بازی
- جزئیات، چیزهایی هستند که انسان‌ها، سایر سیستم‌ها و یا برنامه‌نویسان را قادر می‌کنند که با پالیسی ارتباط برقرار کنند، اما روی رفتار پالیسی به هیچ عنوان اثری ندارند
    - برای مثال رابط کاربری

- در ادامه یک مجموعه مثال از جزئیات زده
    - انتخاب پایگاه داده - پالیسی نیازی ندارد که بداند داده‌ها چطور و کجا ذخیره می‌شوند
    - انتخاب وب‌سرور- چون منطق سیستم اصلا نیازی ندارد که بداند باید تحت وب کار کند
    - ‫انتخاب REST - باز هم منطق نیازی به دانستن نوع ارتباط سیستم با جهان خارج ندارد
    - ‫استفاده از یک dependency injection framework - منطق سیستم نیازی ندارد که بداند چطور dependencyهای سیستم resolve می‌شوند
- یک معمار خوب تعداد تصمیماتی را که نمی‌گیرد بیشینه می‌کند
- در ادامه سه مثال عینی آورده که چطور این «باز گذاشتن گزینه‌ها» کمک کرده