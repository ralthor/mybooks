# فصل سیزدهم: انسجام کامپوننت

کدام کلاس‌ها به کدام کامپوننت‌ها تعلق دارند؟

سه اصل انسجام کامپوننت که قابلیت استفاده مجدد و توسعه‌پذیری ایجاد می‌کنند

- REP: The Reuse/Release Equivalence Principle اصل برابری ریلیز و استفاده مجدد
    
    استفاده مجدد بدون وجود سیستمی برای ردگیری بسته‌ها و شماره ریلیز ممکن نیست
    
    کلاس‌های یک کامپوننت باید با هم قابل ریلیز باشند
    
    این اصل از دو اصل بعدی ضعیف‌تر است و معمولا برای رعایت آن دو نقض می‌شود
    
- CCP: The Component Clusure Principle اصل بستار کامپوننت
    
    ‫همان اصل SRP است (Single Responsibility Principle) اما برای بسته‌ها.
    
    کامپوننت نباید چند دلیل برای تغییر داشته باشد
    
    برای بسیاری از اپلیکیشن‌ها قابلیت نگه‌داری بیشتر از استفاده مجدد اهمیت دارد
    
    پس دوست داریم تغییر را در یک کامپوننت نگه داریم
    
    این اصل می‌گوید همه‌ی کلاس‌هایی که به یک دلیل مشترک تغییر می‌کنند در یک کامپوننت نگه داریم
    
    ‫خیلی به OCP نزدیک است
    
    OCP: Open Closed Principle
    
- CRP: The Common Reuse Principle
    
    کاربران یک کامپوننت را به تغییراتی که نیاز ندارند وابسته نکنیم
    
    این اصل می‌گوید چه کلاس‌هایی را **نباید** در یک کامپوننت با هم قرار دهیم
    
    ‫برای مثال یک کلاس container و iteratorهای مربوط به آن باید در یک کامپوننت قرار بگیرند به خاطر کاپلینگ بالا
    
    می‌خواهیم مطمئن شویم که وقتی تعدادی کلاس در یک کامپوننت قرار می‌گیرند غیرقابل جداسازی هستند، یعنی نمی‌توان به تعدادی از آن‌ها وابسته بود و به تعدادی نه
    
    ‫این اصل حالت عمومی از ISP است: به چیزهایی که نیاز نداری وابسته نباش!
    
    ISP: Interface Segregation Principle
    

این سه اصل با هم در تضاد هستند و این در شکل زیر نشان داده شده

دو اصل بالای نمودار به بزرگ‌تر کردن کامپوننت‌ها تمایل دارند و پایینی کامپوننت‌ها را به سمت کوچک‌تر شدن هل می‌دهد

جملات روی یال‌های گراف هزینه‌ی رها کردن اصل راس مقابل است

![Untitled](%D9%81%D8%B5%D9%84%20%D8%B3%DB%8C%D8%B2%D8%AF%D9%87%D9%85%20%D8%A7%D9%86%D8%B3%D8%AC%D8%A7%D9%85%20%DA%A9%D8%A7%D9%85%D9%BE%D9%88%D9%86%D9%86%D8%AA%204ba1f011c5ec4dac9dce9e36e91a72d3/Untitled.png)

یک معمار خوب نقطه‌ای روی نمودار می‌یابد که دغدغه‌ی کنونی تیم توسعه را پوشش دهد

این اصول مجموعه قوانینی برای قراردهی کلاس‌ها در کامپوننت‌ها فراهم می‌کنند، اما این قوانین پویا هستند.

یعنی ممکن است کلاس‌هایی که اکنون مقتضی‌ست که در یک کامپوننت قرار بگیرند، سال دیگر مقضی باشد که در کامپوننت‌های مجزا باشند

به همین ترتیب ترکیب‌بندی کامپوننت‌ها نیز ممکن است دچار تغییر شود